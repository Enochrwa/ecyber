# backend/malware_events_namespace.py
import logging
from socketio import AsyncNamespace
from typing import Any, Dict
from sio_instance import sio # Import the main sio server instance

logger = logging.getLogger(__name__)

class MalwareEventsNamespace(AsyncNamespace):
    def __init__(self, namespace: str):
        super().__init__(namespace)
        logger.info(f"MalwareEventsNamespace initialized for namespace: {namespace}")

    async def on_connect(self, sid: str, environ: Dict[str, Any]):
        logger.info(f"Malware service client connected to /malware_events: {sid}")
        # This namespace is primarily for the malware.py service to connect TO.
        # Frontend clients will listen on the main (default) namespace or other client-facing namespaces.

    async def on_disconnect(self, sid: str):
        logger.info(f"Malware service client disconnected from /malware_events: {sid}")

    # Generic event handler to catch all events from malware.py client
    # async def on_catch_all_malware_event(self, event: str, sid: str, data: Any):
    #     logger.info(f"Received event '{event}' from malware service client {sid} in /malware_events: {str(data)[:200]}")
    #     # Re-emit this event on the default namespace for frontend clients to receive
    #     # Prepend "malware_" to avoid event name collisions if frontend also uses generic names like "file_alert"
    #     frontend_event_name = f"malware_{event}"
    #     logger.info(f"Relaying to frontend as '{frontend_event_name}'")
    #     try:
    #         # Emit to all clients connected to the default namespace
    #         await sio.emit(frontend_event_name, data, namespace='/') # Emitting to default namespace
    #     except Exception as e:
    #         logger.error(f"Error relaying malware event '{frontend_event_name}' to frontend: {e}")

    # Based on the instruction: "Let's assume malware.py emits specific, known event names like "file_alert", "process_alert".
    # So, we will add explicit handlers for expected events."
    # The catch-all is commented out in favor of specific handlers below.

    async def on_file_alert(self, sid: str, data: Dict[str, Any]):
        logger.info(f"MalwareEventsNS: Received 'file_alert' from {sid}. Data: {str(data)[:100]}")
        await sio.emit('malware_file_alert', data, namespace='/') # Relay to frontend

    async def on_process_alert(self, sid: str, data: Dict[str, Any]):
        logger.info(f"MalwareEventsNS: Received 'process_alert' from {sid}. Data: {str(data)[:100]}")
        await sio.emit('malware_process_alert', data, namespace='/') # Relay to frontend

    async def on_directory_scan_alert(self, sid: str, data: Dict[str, Any]):
        logger.info(f"MalwareEventsNS: Received 'directory_scan_alert' from {sid}. Data: {str(data)[:100]}")
        await sio.emit('malware_directory_scan_alert', data, namespace='/') # Relay to frontend
        
    async def on_malicious_connection(self, sid: str, data: Dict[str, Any]):
        logger.info(f"MalwareEventsNS: Received 'malicious_connection' from {sid}. Data: {str(data)[:100]}")
        await sio.emit('malware_malicious_connection', data, namespace='/') # Relay to frontend

    async def on_threat_intel_update(self, sid: str, data: Dict[str, Any]):
        logger.info(f"MalwareEventsNS: Received 'threat_intel_update' from {sid}. Data: {str(data)[:100]}")
        await sio.emit('malware_threat_intel_update', data, namespace='/') # Relay to frontend
