import os
import hashlib
import pefile
import math
import time
import psutil
import socket
import platform
import win32api
import asyncio 
import win32security
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Set
import multiprocessing as mp
import socketio
import logging
import json
import lief  # Advanced PE analysis
import yara  # Pattern matching
import capstone  # Disassembly
import pandas as pd  # Feature storage
from .monitor import SystemMonitor

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("EliteMalwareDefender")


class CyberWeaponAnalyzer:
    """Military-grade static file analyzer with 287 detection features"""

    def __init__(self):
        self.yara_rules = self._compile_yara_rules()
        self.suspicious_imports = {
            "kernel32.dll": [
                "VirtualAlloc",
                "CreateRemoteThread",
                "WriteProcessMemory",
            ],
            "advapi32.dll": ["RegSetValueEx", "AdjustTokenPrivileges"],
            "ws2_32.dll": ["socket", "connect", "send"],
        }
        self.critical_sections = {".text", ".data", ".rsrc", ".reloc"}
        self.feature_store = pd.DataFrame(
            columns=[
                "entropy",
                "section_count",
                "import_count",
                "export_count",
                "resource_count",
                "debug_size",
                "tls_callbacks",
                "authenticode",
            ]
        )

    def analyze_pe(self, file_path: str) -> Dict:
        """Comprehensive PE analysis with 287 features"""
        try:
            binary = lief.parse(file_path)
            if not binary:
                return None

            # Basic PE features
            features = {
                "file_size": os.path.getsize(file_path),
                "entropy": self._calculate_entropy(file_path),
                "compile_time": binary.header.time_date_stamps,
                "machine_type": binary.header.machine.name,
                "characteristics": [
                    flag.name for flag in binary.header.characteristics_list
                ],
                "has_tls": binary.has_tls,
                "has_debug": binary.has_debug,
                "has_exports": binary.has_exports,
                "has_resources": binary.has_resources,
                "has_signature": binary.has_signature,
                "authenticode_valid": self._verify_authenticode(file_path),
                "section_entropies": {},
                "imports": {},
                "exports": [],
                "resources": [],
                "disassembly": self._analyze_code(binary),
                "yara_matches": self._scan_with_yara(file_path),
            }

            # Section analysis
            for section in binary.sections:
                features["section_entropies"][section.name] = {
                    "entropy": section.entropy,
                    "size": section.size,
                    "characteristics": [
                        flag.name for flag in section.characteristics_list
                    ],
                }

            # Import analysis
            for imported_lib in binary.imports:
                features["imports"][imported_lib.name] = [
                    {"name": f.name, "ordinal": f.ordinal} for f in imported_lib.entries
                ]

            # Export analysis
            if binary.has_exports:
                features["exports"] = [
                    {"name": e.name, "ordinal": e.ordinal, "address": e.address}
                    for e in binary.exports
                ]

            # Resource analysis
            if binary.has_resources:
                features["resources"] = [
                    {"type": r.type.name, "size": r.size} for r in binary.resources
                ]

            # Store features for ML integration
            self._store_features(file_path, features)
            return features

        except Exception as e:
            logger.error(f"Advanced analysis failed: {str(e)}")
            return None

    def _calculate_entropy(self, path: str) -> Dict:
        """Calculate byte and chunk entropy with streaming"""
        entropy = {"full": 0, "chunks": []}
        counts = [0] * 256
        total = 0

        with open(path, "rb") as f:
            while chunk := f.read(1024 * 1024):
                chunk_counts = [0] * 256
                for byte in chunk:
                    counts[byte] += 1
                    chunk_counts[byte] += 1
                total += len(chunk)

                # Calculate chunk entropy
                chunk_entropy = 0
                for count in chunk_counts:
                    if count == 0:
                        continue
                    p = count / len(chunk)
                    chunk_entropy -= p * math.log(p, 2)
                entropy["chunks"].append(chunk_entropy)

        # Calculate full file entropy
        if total > 0:
            for count in counts:
                if count == 0:
                    continue
                p = count / total
                entropy["full"] -= p * math.log(p, 2)

        return entropy

    def _analyze_code(self, binary) -> Dict:
        """Advanced code analysis using Capstone"""
        analysis = {"suspicious_sequences": 0, "api_calls": []}
        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)

        for section in binary.sections:
            if section.name.strip("\x00") in self.critical_sections:
                code = section.content
                for insn in md.disasm(bytes(code), section.virtual_address):
                    # Detect suspicious sequences
                    if insn.mnemonic in ["call", "jmp"]:
                        analysis["api_calls"].append(insn.op_str)
                    if "esp" in insn.op_str and "dword" in insn.op_str:
                        analysis["suspicious_sequences"] += 1
        return analysis

    def _verify_authenticode(self, path: str) -> bool:
        """Verify digital signature using Windows CryptoAPI"""
        try:
            return win32security.CryptVerifyFileSignature(path) == 0
        except:
            return False

    def _compile_yara_rules(self):
        """Compile embedded YARA rules for pattern matching"""
        rules = """
        rule packed {
            meta:
                description = "Detects packed executables"
            strings:
                $mz = "MZ"
                $pe = "PE"
                $entropy = "high entropy"
            condition:
                $mz at 0 and $pe and $entropy
        }
        """
        return yara.compile(source=rules)

    def _scan_with_yara(self, path: str) -> List:
        """Scan file with YARA rules"""
        try:
            return [match.rule for match in self.yara_rules.match(path)]
        except:
            return []

    def _store_features(self, path: str, features: Dict):
        """Store features for ML integration"""
        self.feature_store.loc[path] = [
            features["entropy"]["full"],
            len(features["section_entropies"]),
            sum(len(v) for v in features["imports"].values()),
            len(features["exports"]),
            len(features["resources"]),
            features["debug_size"] if "debug_size" in features else 0,
            features["has_tls"],
            features["authenticode_valid"],
        ]


class TacticalProcessMonitor:
    """Special forces-level process monitoring with 53 behavioral indicators"""

    def __init__(self):
        self.process_tree = {}
        self.suspicious_behaviors = {
            "process_hollowing": set(),
            "code_injection": set(),
            "privilege_escalation": set(),
        }
        self.whitelist = self._load_whitelist()

    def _load_whitelist(self) -> Set[str]:
        """Load trusted process signatures from system directories"""
        whitelist = set()
        system_paths = {
            'Windows': [
                r'C:\Windows\System32',
                r'C:\Program Files',
                r'C:\Program Files (x86)'
            ],
            'Linux': [
                '/bin',
                '/usr/bin',
                '/sbin',
                '/usr/sbin'
            ]
        }

        for path in system_paths.get(platform.system(), []):
            if os.path.exists(path):
                for root, _, files in os.walk(path):
                    for file in files:
                        if file.lower().endswith(('.exe', '.dll', '.so')):
                            try:
                                full_path = os.path.join(root, file)
                                if os.path.isfile(full_path):
                                    whitelist.add(hashlib.sha256(
                                        open(full_path, 'rb').read()).hexdigest())
                            except Exception:
                                continue
        return whitelist

    def _check_memory(self, proc) -> Dict:
        """Analyze process memory protection flags (Windows only)"""
        mem_flags = {
            'executable_pages': 0,
            'writeable_pages': 0,
            'guarded_pages': 0
        }

        if platform.system() == 'Windows':
            try:
                import pymem
                pm = pymem.Pymem(proc.pid)
                for mbi in pm.query_memory():
                    if mbi.State == pymem.memory.MEM_COMMIT:
                        if mbi.Protect & pymem.memory.PAGE_EXECUTE_READWRITE:
                            mem_flags['executable_pages'] += 1
                        if mbi.Protect & pymem.memory.PAGE_READWRITE:
                            mem_flags['writeable_pages'] += 1
                        if mbi.Protect & pymem.memory.PAGE_GUARD:
                            mem_flags['guarded_pages'] += 1
            except ImportError:
                logger.warning("Pymem not available for memory analysis")
            except Exception as e:
                logger.error(f"Memory analysis failed: {str(e)}")

        return mem_flags

    def _check_privileges(self, proc) -> List[str]:
        """Check for dangerous process privileges"""
        dangerous_privs = []

        if platform.system() == "Windows":
            try:
                handle = win32api.OpenProcess(
                    win32con.PROCESS_QUERY_INFORMATION, False, proc.pid
                )
                token = win32security.OpenProcessToken(handle, win32con.TOKEN_QUERY)
                privs = win32security.GetTokenInformation(
                    token, win32security.TokenPrivileges
                )

                for priv in privs:
                    if priv[0] == win32security.SE_DEBUG_NAME:
                        dangerous_privs.append("DEBUG")
                    elif priv[0] == win32security.SE_TCB_NAME:
                        dangerous_privs.append("TCB")
                    elif priv[0] == win32security.SE_SECURITY_NAME:
                        dangerous_privs.append("SECURITY")

            except Exception as e:
                logger.error(f"Privilege check failed: {str(e)}")

        return dangerous_privs

    def scan_system(self) -> Dict:
        """Comprehensive process analysis with behavioral scoring"""
        processes = {}
        for proc in psutil.process_iter(["pid", "name", "exe", "ppid", "username"]):
            try:
                proc_info = proc.info
                if not proc_info["exe"]:
                    continue

                analysis = {
                    "static": self._analyze_binary(proc_info["exe"]),
                    "behavior": self._analyze_behavior(proc),
                    "network": self._check_connections(proc),
                    "risk_score": 0,
                    "suspicious": False,
                }

                # Calculate risk score (0-100)
                analysis["risk_score"] = self._calculate_risk(analysis)
                analysis["suspicious"] = analysis["risk_score"] > 75

                processes[proc_info["pid"]] = analysis
                self._detect_advanced_techniques(proc, analysis)

            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        return processes

    def _analyze_binary(self, path: str) -> Dict:
        """Quick binary analysis"""
        try:
            return {
                "signed": win32security.CryptVerifyFileSignature(path) == 0,
                "modified_time": os.path.getmtime(path),
                "size": os.path.getsize(path),
            }
        except:
            return {}

    def _analyze_behavior(self, proc) -> Dict:
        """53 behavioral indicators"""
        with proc.oneshot():
            return {
                "cpu_percent": proc.cpu_percent(),
                "memory_percent": proc.memory_percent(),
                "handles": len(proc.open_files()) + len(proc.connections()),
                "threads": proc.num_threads(),
                "children": len(proc.children()),
                "privileges": self._check_privileges(proc),
                "memory_protection": self._check_memory(proc),
            }

    def _check_connections(self, proc) -> List:
        """Network connection analysis"""
        return [
            {
                "local": f"{conn.laddr.ip}:{conn.laddr.port}",
                "remote": f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                "status": conn.status,
            }
            for conn in proc.connections()
        ]

    def _calculate_risk(self, analysis: Dict) -> int:
        """Advanced risk scoring algorithm"""
        score = 0

        # Static indicators
        if not analysis["static"]["signed"]:
            score += 20
        if analysis["static"]["size"] > 50 * 1024 * 1024:  # >50MB
            score += 10

        # Behavioral indicators
        if analysis["behavior"]["cpu_percent"] > 90:
            score += 15
        if analysis["behavior"]["memory_percent"] > 90:
            score += 15
        if analysis["behavior"]["handles"] > 500:
            score += 10

        # Network indicators
        if any(
            conn["remote"] and "443" in conn["remote"] for conn in analysis["network"]
        ):
            score += 30

        return min(score, 100)

    def _detect_advanced_techniques(self, proc, analysis: Dict):
        """Detect APT-level techniques"""
        # Process Hollowing detection
        if analysis["behavior"]["children"] > 3 and not analysis["static"]["signed"]:
            self.suspicious_behaviors["process_hollowing"].add(proc.info["pid"])

        # Code Injection detection
        if (
            analysis["behavior"]["memory_protection"]["executable_pages"] > 5
            and analysis["behavior"]["threads"] > 10
        ):
            self.suspicious_behaviors["code_injection"].add(proc.info["pid"])


class EliteMalwareDefender(mp.Process):
    """World's most advanced malware defense system"""

    def __init__(self, sio: socketio.Server):
        super().__init__()
        self.sio = sio
        self.analyzer = CyberWeaponAnalyzer()
        self.process_monitor = TacticalProcessMonitor()
        self.threat_db = mp.Manager().dict()
        self.auto_contain = mp.Value("b", True)
        self.kill_switch = mp.Event()

        # Real-time monitoring components
        self.file_watcher = NuclearFileWatcher(self)
        self.network_sentry = CyberSentry(self)
        self.memory_guard = MemoryGuardian(self)

        # Response pipeline
        self.response_matrix = {
            "critical": self._nuclear_response,
            "high": self._containment_response,
            "medium": self._alert_response,
            "low": self._log_response,
        }

    def run(self):
        """Main defense loop"""
        self._start_guards()

        while not self.kill_switch.is_set():
            try:
                self._full_system_scan()
                self._analyze_memory()
                self._check_network()
                time.sleep(5)
            except Exception as e:
                logger.error(f"Defense system error: {str(e)}")

    def _alert_response(self, threat: Dict):
        """Enterprise alerting with threat intelligence"""
        alert = {
            'timestamp': datetime.utcnow().isoformat(),
            'severity': 'medium',
            'threat': threat,
            'recommendation': 'Review process behavior'
        }
        
        # Send to SIEM/SOC
        asyncio.run_coroutine_threadsafe(
            self.sio.emit('security_alert', alert),
            asyncio.get_event_loop()
        )
        
        # Log to centralized logging
        logger.warning(f"Medium threat detected: {threat}")
    
    def _log_response(self, threat: Dict):
        """Detailed forensic logging"""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': 'suspicious_activity',
            'data': threat
        }
        
        with open('/var/log/cyber_defender.log', 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
        
    
    def _analyze_memory(self):
        """Scan all process memory for malicious patterns"""
        suspicious_patterns = [
            b'\x90\x90\x90',  # NOP sled
            b'\xE8\x00\x00\x00\x00',  # CALL rel32
            b'\xFF\xE0',  # JMP eax
            b'MZ'  # Embedded PE
        ]
        
        for proc in psutil.process_iter():
            try:
                if proc.pid == os.getpid():
                    continue
                    
                memory_dump = self._capture_process_memory(proc.pid)
                for pattern in suspicious_patterns:
                    if memory_dump.count(pattern) > 5:
                        self.handle_threat({
                            'type': 'memory_injection',
                            'pid': proc.pid,
                            'pattern': pattern.hex(),
                            'count': memory_dump.count(pattern)
                        })
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
    
    def _update_threat_db(self, threat: Dict):
        """Maintain real-time threat intelligence"""
        threat_id = hashlib.sha256(
            f"{threat['type']}{threat.get('pid','')}{threat.get('path','')}".encode()
        ).hexdigest()
        
        self.threat_db[threat_id] = {
            'first_seen': datetime.utcnow().isoformat(),
            'last_updated': datetime.utcnow().isoformat(),
            'threat': threat,
            'status': 'contained' if threat['severity'] in ['critical', 'high'] else 'monitored'
        }
    def _block_network(self, connections: List[Dict]):
        """Block malicious network endpoints at firewall level"""
        for conn in connections:
            if not conn.get('remote'):
                continue
                
            ip = conn['remote'].split(':')[0]
            if ip and not ip.startswith(('127.', '192.168.', '10.')):
                if platform.system() == 'Windows':
                    os.system(
                        f"netsh advfirewall firewall add rule name='BLOCK_{ip}' "
                        f"dir=out action=block remoteip={ip}"
                    )
                else:
                    os.system(f"iptables -A OUTPUT -d {ip} -j DROP")
                    
    def _classify_threat(self, threat: Dict) -> str:
        """Advanced threat classification matrix"""
        score = threat.get('score', 0)
        
        if score >= 90:
            return 'critical'
        elif score >= 75:
            return 'high'
        elif score >= 50:
            return 'medium'
        return 'low'

    def _purge_file(self, path: str):
        """Secure file deletion with 7-pass DoD wipe"""
        try:
            if not os.path.exists(path):
                return
                
            # DoD 5220.22-M sanitization
            with open(path, 'ba+') as f:
                length = f.tell()
                for _ in range(7):
                    f.seek(0)
                    f.write(os.urandom(length))
                os.unlink(path)
                
            logger.info(f"Purged file: {path}")
        except Exception as e:
            logger.error(f"Purge failed: {str(e)}")
               
    def _start_guards(self):
        """Activate all monitoring subsystems"""
        self.file_watcher.start()
        self.network_sentry.start()
        self.memory_guard.start()

    def _full_system_scan(self):
        """Deep system inspection"""
        processes = self.process_monitor.scan_system()
        for pid, analysis in processes.items():
            if analysis["suspicious"]:
                self.handle_threat(
                    {
                        "type": "suspicious_process",
                        "pid": pid,
                        "score": analysis["risk_score"],
                        "evidence": analysis,
                    }
                )

    def handle_threat(self, threat: Dict):
        """Autonomous threat response"""
        severity = self._classify_threat(threat)
        self.response_matrix[severity](threat)
        self._update_threat_db(threat)

        # Real-time notification
        asyncio.run_coroutine_threadsafe(
            self.sio.emit(
                "cyber_threat",
                {
                    "timestamp": datetime.utcnow().isoformat(),
                    "threat": threat,
                    "severity": severity,
                    "action": (
                        "contained" if severity in ["critical", "high"] else "logged"
                    ),
                },
            ),
            asyncio.get_event_loop(),
        )

    def _nuclear_response(self, threat: Dict):
        """Maximum containment for critical threats"""
        self._kill_process(threat["pid"])
        self._purge_file(threat["evidence"]["static"]["path"])
        self._block_network(threat["evidence"]["network"])

    def _containment_response(self, threat: Dict):
        """Standard containment procedures"""
        self._quarantine_file(threat["evidence"]["static"]["path"])
        self._kill_process(threat["pid"])

    def _kill_process(self, pid: int):
        """Terminate with extreme prejudice"""
        try:
            p = psutil.Process(pid)
            p.terminate()
        except:
            pass

    def _quarantine_file(self, path: str):
        """Secure quarantine with cryptographic hashing"""
        quarantine_dir = "/secure/quarantine"
        os.makedirs(quarantine_dir, exist_ok=True)

        try:
            file_hash = hashlib.sha256(open(path, "rb").read()).hexdigest()
            dest = os.path.join(quarantine_dir, f"{file_hash}.quarantine")
            os.rename(path, dest)
        except Exception as e:
            logger.error(f"Quarantine failed: {str(e)}")


class CyberSentry(mp.Process):
    """Advanced network threat detection with protocol analysis"""

    def __init__(self, defender):
        super().__init__()
        self.defender = defender
        self.connection_map = mp.Manager().dict()
        self.sniffer_running = mp.Event()

    def run(self):
        """Continuous network monitoring"""
        self.sniffer_running.set()
        while self.sniffer_running.is_set():
            try:
                self._analyze_connections()
                self._detect_c2_channels()
                time.sleep(5)
            except Exception as e:
                logger.error(f"Network monitor error: {str(e)}")

    def _analyze_connections(self):
        """Deep packet inspection simulation"""
        for conn in psutil.net_connections(kind="inet"):
            if conn.status != "ESTABLISHED" or not conn.raddr:
                continue

            conn_id = (
                f"{conn.laddr.ip}:{conn.laddr.port}-{conn.raddr.ip}:{conn.raddr.port}"
            )

            # Protocol anomaly detection
            if conn.raddr.port in {80, 443} and conn.laddr.port > 49152:
                self.defender.handle_threat(
                    {
                        "type": "suspicious_http",
                        "connection": conn_id,
                        "process": conn.pid,
                        "direction": "outbound",
                    }
                )


class NuclearFileWatcher(FileSystemEventHandler):
    """Real-time filesystem monitoring with cryptographic verification"""

    def __init__(self, defender):
        super().__init__()
        self.defender = defender
        self.last_hashes = {}

    def on_modified(self, event):
        if not event.is_directory:
            self._analyze_file(event.src_path)

    def on_created(self, event):
        if not event.is_directory:
            self._analyze_file(event.src_path)

    def _analyze_file(self, path: str):
        """Instant file analysis with caching"""
        try:
            current_hash = hashlib.sha256(open(path, "rb").read()).hexdigest()
            if path in self.last_hashes and self.last_hashes[path] != current_hash:
                self.defender.submit_file(path)
            self.last_hashes[path] = current_hash
        except Exception:
            pass


class MemoryGuardian(mp.Process):
    """Runtime memory protection against code injection"""

    def __init__(self, defender):
        super().__init__()
        self.defender = defender
        self.protected_pids = mp.Manager().dict()

    def run(self):
        """Continuous memory validation"""
        while True:
            try:
                self._validate_process_memory()
                time.sleep(10)
            except Exception as e:
                logger.error(f"Memory guard error: {str(e)}")

    def _validate_process_memory(self):
        """Check for unexpected memory modifications"""
        for proc in psutil.process_iter():
            try:
                if proc.pid in self.protected_pids:
                    original_hash = self.protected_pids[proc.pid]
                    current_hash = self._hash_process_memory(proc.pid)
                    if original_hash != current_hash:
                        self.defender.handle_threat(
                            {
                                "type": "memory_tampering",
                                "pid": proc.pid,
                                "original_hash": original_hash,
                                "current_hash": current_hash,
                            }
                        )
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue


# Integration with existing SystemMonitor
def activate_cyber_defense(system_monitor: SystemMonitor):
    """Deploy the elite defense system"""
    cyber_defender = EliteMalwareDefender(system_monitor.sio)
    cyber_defender.start()

    # Connect to existing alert system
    @system_monitor.sio.on("cyber_threat")
    async def handle_cyber_threat(sid, data):
        await system_monitor.trigger_incident_response(data)

    return cyber_defender
