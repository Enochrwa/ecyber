import multiprocessing
import time
from typing import Optional, Callable
from socketio import Client
from .models import ScanType, ScanResult
from .utils import get_system_info
from config import settings


class VulnerabilityScanner:
    def __init__(self, sio: Optional[Client] = None):
        self.sio = sio
        self.active_scans = {}
        self.scan_lock = multiprocessing.Lock()

    def _emit_event(self, event: str, data: dict):
        if self.sio:
            self.sio.emit(event, data)

    def _calculate_risk_score(self, vulnerabilities: list) -> float:
        """Calculate weighted risk score based on vulnerabilities"""
        total = 0.0
        weights = {
            "critical": 1.0,
            "high": 0.7,
            "medium": 0.4,
            "low": 0.2,
            "info": 0.05,
        }

        for vuln in vulnerabilities:
            total += weights.get(vuln.threat_level.lower(), 0) * vuln.risk_score

        return min(total, 100.0)

    def quick_scan(self) -> ScanResult:
        """Perform quick surface-level scan"""
        start_time = time.time()
        self._emit_event("scan_started", {"type": "quick"})

        # Import detectors as needed to avoid circular imports
        from .detectors.processes import check_suspicious_processes
        from .detectors.network import check_risky_ports, check_suspicious_connections
        from .detectors.persistence import check_autorun_entries
        from .detectors.files import check_high_entropy_files

        vulnerabilities = []

        # Run checks
        vulnerabilities.extend(check_suspicious_processes())
        vulnerabilities.extend(check_risky_ports())
        vulnerabilities.extend(check_suspicious_connections())
        vulnerabilities.extend(check_autorun_entries())
        vulnerabilities.extend(check_high_entropy_files())

        risk_score = self._calculate_risk_score(vulnerabilities)

        result = ScanResult(
            scan_type=ScanType.QUICK,
            vulnerabilities=vulnerabilities,
            total_risk_score=risk_score,
            duration=time.time() - start_time,
            timestamp=time.time(),
            system_info=get_system_info(),
        )

        self._emit_event("scan_completed", result.dict())
        return result

    def standard_scan(self) -> ScanResult:
        """Perform recommended standard scan"""
        start_time = time.time()
        self._emit_event("scan_started", {"type": "standard"})

        # First run quick scan checks
        quick_result = self.quick_scan()
        vulnerabilities = quick_result.vulnerabilities

        # Additional checks for standard scan
        from .detectors.malware import check_known_malware
        from .detectors.processes import check_process_signatures
        from .detectors.misconfig import check_firewall_status, check_update_status

        vulnerabilities.extend(check_known_malware())
        vulnerabilities.extend(check_process_signatures())
        vulnerabilities.extend(check_firewall_status())
        vulnerabilities.extend(check_update_status())

        risk_score = self._calculate_risk_score(vulnerabilities)

        result = ScanResult(
            scan_type=ScanType.STANDARD,
            vulnerabilities=vulnerabilities,
            total_risk_score=risk_score,
            duration=time.time() - start_time,
            timestamp=time.time(),
            system_info=get_system_info(),
        )

        self._emit_event("scan_completed", result.dict())
        return result

    def comprehensive_scan(self) -> ScanResult:
        """Perform deep comprehensive scan"""
        start_time = time.time()
        self._emit_event("scan_started", {"type": "comprehensive"})

        # First run standard scan checks
        standard_result = self.standard_scan()
        vulnerabilities = standard_result.vulnerabilities

        # Additional deep checks
        from .detectors.malware import deep_malware_scan
        from .detectors.network import full_port_scan
        from .detectors.credentials import audit_password_hashes
        from .detectors.software import check_vulnerable_software
        from .detectors.privilege import check_privilege_escalation
        from .detectors.permissions import check_file_permissions

        # Run in parallel where possible
        with multiprocessing.Pool() as pool:
            results = pool.starmap(
                lambda f, *args: f(*args),
                [
                    (deep_malware_scan,),
                    (full_port_scan, "localhost"),
                    (audit_password_hashes,),
                    (check_vulnerable_software,),
                    (check_privilege_escalation,),
                    (check_file_permissions, ["/etc", "/usr/bin", "/tmp"]),
                ],
            )

            for result in results:
                vulnerabilities.extend(result)

        risk_score = self._calculate_risk_score(vulnerabilities)

        result = ScanResult(
            scan_type=ScanType.COMPREHENSIVE,
            vulnerabilities=vulnerabilities,
            total_risk_score=risk_score,
            duration=time.time() - start_time,
            timestamp=time.time(),
            system_info=get_system_info(),
        )

        self._emit_event("scan_completed", result.dict())
        return result

    def start_silent_monitor(self):
        """Start continuous background monitoring"""
        from services.realtime_monitor import RealTimeMonitor

        self.monitor = RealTimeMonitor(sio=self.sio)
        self.monitor_process = multiprocessing.Process(
            target=self.monitor.run, daemon=True
        )
        self.monitor_process.start()

    def stop_silent_monitor(self):
        """Stop background monitoring"""
        if hasattr(self, "monitor_process"):
            self.monitor_process.terminate()
            self.monitor_process.join()
