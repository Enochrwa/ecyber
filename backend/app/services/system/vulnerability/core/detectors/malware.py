import os
import yara
import mmap
import hashlib
import lief
import pefile
import json
import magic
import tempfile
from typing import List, Tuple, Optional, Generator
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from ..models import Vulnerability, ThreatLevel
from config import settings


class AdvancedMalwareScanner:
    def __init__(self):
        self.yara_rules = self._load_yara_rules()
        self.suspicious_strings = self._load_suspicious_strings()
        self.malware_hashes = self._load_malware_hashes()
        self.max_file_size = 100 * 1024 * 1024  # 100MB
        self.executor = ThreadPoolExecutor(max_workers=8)

    def _load_yara_rules(self):
        """Load and compile YARA rules with error handling"""
        try:
            return yara.compile(filepath=str(settings.YARA_RULES))
        except yara.Error as e:
            raise RuntimeError(f"Failed to load YARA rules: {str(e)}")

    def _load_suspicious_strings(self) -> List[str]:
        """Load suspicious strings patterns"""
        suspicious_path = settings.RULES_DIR / "suspicious_strings.txt"
        if suspicious_path.exists():
            with open(suspicious_path, "r") as f:
                return [line.strip() for line in f if line.strip()]
        return []

    def _load_malware_hashes(self) -> dict:
        """Load malware hash database"""
        with open(settings.MALWARE_HASHES, "r") as f:
            return json.load(f)

    def _file_generator(self) -> Generator[Path, None, None]:
        """Generate files for scanning, excluding system/protected paths"""
        exclude_dirs = {
            "/proc",
            "/sys",
            "/dev",
            "/run",
            "/snap",
            "/var/lib/docker",
            "/var/cache",
            "/tmp",
            str(Path.home() / ".cache"),
            str(Path.home() / ".local/share/Trash"),
        }

        for root, dirs, files in os.walk("/", topdown=True):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if os.path.join(root, d) not in exclude_dirs]

            for file in files:
                file_path = Path(root) / file
                try:
                    if file_path.is_file() and os.access(file_path, os.R_OK):
                        yield file_path
                except (PermissionError, OSError):
                    continue

    def _calculate_hashes(self, file_path: Path) -> Tuple[str, str, str]:
        """Calculate multiple hash types for a file"""
        sha256 = hashlib.sha256()
        md5 = hashlib.md5()
        ssdeep = pydeep.hash_file(str(file_path))

        with open(file_path, "rb") as f:
            while chunk := f.read(8192):
                sha256.update(chunk)
                md5.update(chunk)

        return sha256.hexdigest(), md5.hexdigest(), ssdeep

    def _analyze_pe_file(self, file_path: Path) -> Optional[Vulnerability]:
        """Perform advanced PE file analysis"""
        try:
            pe = pefile.PE(str(file_path))

            indicators = {
                "packed": False,
                "anti_debug": False,
                "suspicious_imports": [],
                "section_anomalies": [],
            }

            # Check for packing indicators
            if len(pe.sections) > 0 and pe.sections[0].Name.rstrip(b"\x00") == b".text":
                text_section = pe.sections[0]
                if text_section.SizeOfRawData == 0:
                    indicators["packed"] = True

            # Check suspicious imports
            suspicious_dlls = {
                "kernel32.dll",
                "user32.dll",
                "ws2_32.dll",
                "advapi32.dll",
            }
            suspicious_functions = {
                "CreateRemoteThread",
                "WriteProcessMemory",
                "VirtualAllocEx",
                "RegSetValue",
                "WinExec",
                "URLDownloadToFile",
            }

            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode("utf-8", errors="ignore").lower()
                if dll_name in suspicious_dlls:
                    for imp in entry.imports:
                        if (
                            imp.name
                            and imp.name.decode("utf-8", errors="ignore")
                            in suspicious_functions
                        ):
                            indicators["suspicious_imports"].append(
                                f"{dll_name}:{imp.name.decode('utf-8', errors='ignore')}"
                            )

            # Check section anomalies
            for section in pe.sections:
                section_name = section.Name.rstrip(b"\x00").decode(
                    "utf-8", errors="ignore"
                )
                if section.Misc_VirtualSize > section.SizeOfRawData * 2:
                    indicators["section_anomalies"].append(
                        f"Section {section_name} has virtual size much larger than raw size"
                    )

            # Create vulnerability if any indicators found
            if any(indicators.values()):
                return Vulnerability(
                    id=f"pe_anomaly_{hashlib.md5(str(file_path).encode()).hexdigest()[:8]}",
                    name="PE File Anomalies Detected",
                    description=f"Portable Executable {file_path} shows signs of malware",
                    threat_level=ThreatLevel.HIGH,
                    risk_score=80.0,
                    evidence=str(indicators),
                    mitigation="Analyze file with professional malware analysis tools",
                    references=[],
                )

        except Exception:
            return None

    def _analyze_elf_file(self, file_path: Path) -> Optional[Vulnerability]:
        """Perform ELF binary analysis using LIEF"""
        try:
            binary = lief.parse(str(file_path))
            if not binary:
                return None

            indicators = {
                "modified_dynamic_section": False,
                "unusual_segments": [],
                "suspicious_symbols": [],
            }

            # Check for modified dynamic section
            if binary.has_section(".dynamic"):
                dynamic_section = binary.get_section(".dynamic")
                if dynamic_section.size == 0:
                    indicators["modified_dynamic_section"] = True

            # Check for unusual segments
            for segment in binary.segments:
                if segment.type == lief.ELF.SEGMENT_TYPES.LOAD:
                    if (
                        segment.flags
                        != lief.ELF.SEGMENT_FLAGS.R | lief.ELF.SEGMENT_FLAGS.W
                    ):
                        indicators["unusual_segments"].append(
                            f"Segment {segment.type} with flags {segment.flags}"
                        )

            # Check for suspicious symbols
            if binary.has_symbols:
                suspicious_symbols = {"system", "execve", "fork", "ptrace"}
                for symbol in binary.symbols:
                    if symbol.name in suspicious_symbols:
                        indicators["suspicious_symbols"].append(symbol.name)

            if any(indicators.values()):
                return Vulnerability(
                    id=f"elf_anomaly_{hashlib.md5(str(file_path).encode()).hexdigest()[:8]}",
                    name="ELF File Anomalies Detected",
                    description=f"ELF binary {file_path} shows signs of compromise",
                    threat_level=ThreatLevel.HIGH,
                    risk_score=75.0,
                    evidence=str(indicators),
                    mitigation="Analyze with professional tools and consider replacement",
                    references=[],
                )

        except Exception:
            return None

    def _scan_file(self, file_path: Path) -> Optional[List[Vulnerability]]:
        """Perform deep scan of a single file"""
        vulnerabilities = []

        try:
            # Skip large files
            if file_path.stat().st_size > self.max_file_size:
                return None

            # Calculate file hashes
            sha256, md5, ssdeep = self._calculate_hashes(file_path)

            # Check against known malware hashes
            if sha256 in self.malware_hashes:
                malware_info = self.malware_hashes[sha256]
                vulnerabilities.append(
                    Vulnerability(
                        id=f"malware_hash_{sha256[:8]}",
                        name="Known Malware Detected",
                        description=f"File {file_path} matches known malware {malware_info.get('name', '')}",
                        threat_level=ThreatLevel.CRITICAL,
                        risk_score=100.0,
                        evidence=f"SHA256: {sha256}",
                        mitigation="Delete file immediately and investigate system",
                        references=malware_info.get("references", []),
                    )
                )
                return vulnerabilities

            # Check YARA rules
            try:
                with open(file_path, "rb") as f:
                    file_mmap = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
                    matches = self.yara_rules.match(data=file_mmap)
                    file_mmap.close()

                    if matches:
                        rule_names = ", ".join([str(m) for m in matches])
                        vulnerabilities.append(
                            Vulnerability(
                                id=f"yara_match_{sha256[:8]}",
                                name="YARA Rule Match",
                                description=f"File {file_path} matches YARA rules: {rule_names}",
                                threat_level=ThreatLevel.HIGH,
                                risk_score=90.0,
                                evidence=file_path,
                                mitigation="Investigate file and rule matches",
                                references=[],
                            )
                        )
            except Exception:
                pass

            # Check file type and perform format-specific analysis
            file_type = magic.from_file(str(file_path))

            if "PE32" in file_type or "PE64" in file_type:
                pe_vuln = self._analyze_pe_file(file_path)
                if pe_vuln:
                    vulnerabilities.append(pe_vuln)
            elif "ELF" in file_type:
                elf_vuln = self._analyze_elf_file(file_path)
                if elf_vuln:
                    vulnerabilities.append(elf_vuln)

            # Check for suspicious strings
            if any(
                s in file_path.name.lower() for s in ["payload", "inject", "backdoor"]
            ):
                vulnerabilities.append(
                    Vulnerability(
                        id=f"suspicious_name_{sha256[:8]}",
                        name="Suspicious Filename",
                        description=f"File {file_path} has suspicious name",
                        threat_level=ThreatLevel.MEDIUM,
                        risk_score=50.0,
                        evidence=file_path.name,
                        mitigation="Verify file origin and purpose",
                    )
                )

            return vulnerabilities if vulnerabilities else None

        except (PermissionError, OSError, Exception) as e:
            return None

    def deep_malware_scan(self) -> List[Vulnerability]:
        """Perform comprehensive deep malware scan of the filesystem"""
        vulnerabilities = []
        futures = []

        # Process files in parallel
        for file_path in self._file_generator():
            futures.append(self.executor.submit(self._scan_file, file_path))

            # Process completed futures in batches
            if len(futures) >= 100:
                for future in as_completed(futures[:100]):
                    result = future.result()
                    if result:
                        vulnerabilities.extend(result)
                futures = futures[100:]

        # Process remaining futures
        for future in as_completed(futures):
            result = future.result()
            if result:
                vulnerabilities.extend(result)

        return vulnerabilities
