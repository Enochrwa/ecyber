import os
import subprocess
import platform
from socketio import Client
from typing import Optional, List
from ..core.models import Vulnerability


class ThreatBlocker:
    def __init__(self, sio: Optional[Client] = None):
        self.sio = sio
        self.blocked_items = {"processes": set(), "ips": set(), "files": set()}

    def _emit_event(self, event: str, data: dict):
        if self.sio:
            self.sio.emit(event, data)

    def block_threat(self, vulnerability: Vulnerability) -> bool:
        """Take action to block a critical threat"""
        try:
            if "malware" in vulnerability.id or "high_entropy" in vulnerability.id:
                # Block malicious file
                if os.path.exists(vulnerability.evidence):
                    os.remove(vulnerability.evidence)
                    self.blocked_items["files"].add(vulnerability.evidence)
                    self._emit_event(
                        "threat_blocked",
                        {
                            "type": "file",
                            "path": vulnerability.evidence,
                            "action": "deleted",
                            "vulnerability": vulnerability.dict(),
                        },
                    )
                    return True

            elif "network" in vulnerability.id:
                # Block suspicious IP (implementation varies by OS)
                ip = self._extract_ip(vulnerability.evidence)
                if ip:
                    if platform.system() == "Linux":
                        subprocess.run(
                            ["iptables", "-A", "INPUT", "-s", ip, "-j", "DROP"],
                            check=True,
                        )
                    elif platform.system() == "Windows":
                        subprocess.run(
                            [
                                "netsh",
                                "advfirewall",
                                "firewall",
                                "add",
                                "rule",
                                f"name=Block {ip}",
                                "dir=in",
                                "action=block",
                                "remoteip={ip}",
                            ],
                            check=True,
                        )
                    self.blocked_items["ips"].add(ip)
                    self._emit_event(
                        "threat_blocked",
                        {
                            "type": "ip",
                            "ip": ip,
                            "action": "blocked",
                            "vulnerability": vulnerability.dict(),
                        },
                    )
                    return True

            elif "process" in vulnerability.id:
                # Kill suspicious process
                pid = self._extract_pid(vulnerability.evidence)
                if pid:
                    try:
                        if platform.system() == "Linux":
                            subprocess.run(["kill", "-9", str(pid)], check=True)
                        elif platform.system() == "Windows":
                            subprocess.run(
                                ["taskkill", "/F", "/PID", str(pid)], check=True
                            )
                        self.blocked_items["processes"].add(pid)
                        self._emit_event(
                            "threat_blocked",
                            {
                                "type": "process",
                                "pid": pid,
                                "action": "terminated",
                                "vulnerability": vulnerability.dict(),
                            },
                        )
                        return True
                    except subprocess.SubprocessError:
                        return False

            return False

        except Exception as e:
            self._emit_event(
                "block_error", {"error": str(e), "vulnerability": vulnerability.dict()}
            )
            return False

    def _extract_ip(self, evidence: str) -> Optional[str]:
        """Extract IP address from evidence string"""
        # Simple implementation - would need more robust parsing
        import re

        ip_match = re.search(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", evidence)
        return ip_match.group(0) if ip_match else None

    def _extract_pid(self, evidence: str) -> Optional[int]:
        """Extract PID from evidence string"""
        # Simple implementation
        import re

        pid_match = re.search(r"PID[=:\s](\d+)", evidence, re.IGNORECASE)
        return int(pid_match.group(1)) if pid_match else None
